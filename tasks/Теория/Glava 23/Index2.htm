<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index1.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index3.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
<p>&nbsp;</p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3"><b><font size="4">23.1. 
  Методы обучения в системе ODYSSEUS</font></b><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Методы обучения, 
  которые рассматривались в главе 20 (пространство версий и IDЗ), иногда называют 
  <i>методами, основанными на подобии (similarity-based). </i>Реализация обучения 
  на основе этих методов требует обработки больших объемов информации — позитивных 
  и негативных примеров, — из которой извлекаются характерные свойства нового 
  концепта.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Альтернативой 
  таким методам являются <i>методы, основанные на пояснениях (explanation-based), 
  </i>которые позволяют выполнить обобщение на осно.ве <i>единственного </i>обучающего 
  экземпляра. Это становится возможным, поскольку в таких методах процессом обобщения 
  &quot;руководят&quot; знания, специфические для конкретной предметной области. 
  Обучение, основанное на пояснениях, является <i>дедуктивным </i>или <i>аналитическим, 
  </i>а не <i>эмпирическим </i>или <i>индуктивным [Bergadano and Gunetti, 1996]. 
  </i>Иными словами, при такой методике описание нового концепта формируется в 
  результате анализа предъявленного экземпляра в свете имеющихся фоновых знаний.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3"><i>Методика 
  логического вывода на основе прецедентов, </i>которой была посвящена глава 22, 
  позволяет решить новую проблему, адаптируя ранее полученные решения аналогичных 
  проблем. Эта же методика может быть использована и для обучения, поскольку если 
  уж ранее сформированное решение адаптировано применительно к новой проблеме, 
  его можно добавить в базу прецедентов для использования в будущем.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Ниже будут 
  более подробно рассмотрены методика обучения на основе пояснений и возможность 
  использования прецедентов для машинного обучения.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Термином <i>обобщение 
  на основе пояснений (EBG </i>— <i>explanation-based generalization) </i>обозначается 
  независимый от, предметной области метод использования знаний, специфических 
  для предметной области, для контроля процесса обобщения по единственному обучающему 
  экземпляру.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Использование 
  метода EBG предполагает, что система располагает следующей информацией:<br>
  </font></p>
<ul>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> позитивным экземпляром 
    обучающей выборки;<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> теорией предметной 
    области;<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> определением концепта, 
    который система должна &quot;изучить&quot;.<br>
    </font></li>
</ul>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Для формализации 
  этих идей обычно используется язык логического программирования (см. главу 8). 
  В частности, концепт, как правило, представляется в форме <i>предиката, </i>который 
  характеризует то подмножество пространства объектов, которое нас интересует. 
  Например, предикат сuр(Х) может представлять понятие &quot;cuphood&quot; (чашкообразность), 
  которое определено в стиле языка PROLOG как сосуд малого объема (small), обладающий 
  свойствами open (открытый), stable (устойчивый). Напомним, что выражение<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">а :-b.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">читается как 
  &quot;а истинно, если b истинно&quot;. Тогда:</font></p>
<p align="left"><font face="Arial, Helvetica, sans-serif" size="3"> <font face="Verdana, Arial, Helvetica, sans-serif">cup(X) 
  :- small(X), stable(X), open(X).</font><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Знания о предметной 
  области должны включать описания условий, выполнение которых необходимо для 
  того, чтобы объект можно было считать &quot;устойчивым&quot; (stable), например 
  указано, что объект должен иметь плоское дно, определение свойства &quot;открытый&quot; 
  (open) — например, объект должен иметь вогнутую форму, причем центр кривизны 
  должен быть расположен выше основания.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В качестве 
  экземпляра обучающей выборки укажем объект с плоским дном вогнутой формы, диаметр 
  которого не превышает нескольких дюймов. Экземпляр должен &quot;сопровождаться&quot; 
  пояснением, что указанные свойства вполне достаточны для представления понятия 
  &quot;cuphood&quot;. Образец обычно описывается некоторым количеством <i>фундаментальных 
  литералов (ground literals), </i>например:<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">color(red, 
  obj). diameter(4, obj).</font></p>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3"> flat(bottom, 
  obj). concave(top, obj).</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Эти литералы 
  представляют определенный объект obj красного цвета (red) с плоским дном (flat 
  bottom), вогнутый, причем центр кривизны располагается сверху (concave top). 
  Знания о предметной области, представленные ниже, позволяют распознать этот 
  экземпляр как представляющий концепт сир:<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">small(X) 
  :- diameter(Y, X), Y &lt; 5. </font></p>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">stable(X) 
  :- flat(bottom, X). </font></p>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">open(X) 
  :- concave(top, X).</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Обратите внимание 
  — то, что объект obj является чашкой, логически следует из этого фрагмента знаний. 
  Наше пояснение, <i>почему </i>obj является чашкой, фактически есть <i>доказательство. 
  </i>Этим завершается <i>фаза пояснений </i>в EBG.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Далее начинается 
  <i>фаза обобщения</i>— вырабатывается набор достаточных условий, которые существовали 
  при пояснении. Главное, что нужно при этом сделать, — определить самые слабые 
  условия, которых достаточно, чтобы на основании имеющихся знаний прийти к заключению, 
  что obj — это чашка. Полученное в результате обобщение концепта состоит в том, 
  что чашкой является объект с плоским дном, вогнутый, с центром кривизны вверху 
  и диаметром менее 5:<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">cup(X) 
  :- flat (bottom, X), concaveftop, X), diameter(Y, X), Y &lt; 5.</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Обратите внимание 
  на то, что это обобщение логически следует из исходного определения понятия 
  &quot;чашкообразности&quot; и базовых знаний о том, что такое &quot;малый объем&quot;, 
  &quot;устойчивость&quot; и &quot;открытость&quot;. В этом смысле новое обобщение 
  уже было неявно представлено в ранее имевшихся знаниях. Анализ представленного 
  образца позволил сделать это обобщение явным. Кроме того, использование сформированного 
  заранее обобщенного определения &quot;чашкообразности&quot; позволило нам совершенно 
  безболезненно проигнорировать несущественные характеристики, в данном случае 
  — цвет.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3"><i>Обучение 
  на основе прецедентов (CBL </i>— <i>case-based learning) </i>представляет собой 
  подход к обучению, совершенно противоположный методу EBG. Как было показано 
  в главе 22, извлечение информации при таком подходе базируется в основном на 
  подобии аргументов, а не на их логическом анализе. Можно с полным правом утверждать, 
  что процесс адаптации сформулированного ранее решения к новой проблеме не включает 
  обобщения в смысле логического программирования. В качестве дополнительного 
  средства, обеспечивающего использование знаний об отношениях между сущностями 
  предметной области, можно использовать иерархию абстракций, в частности в форме 
  семантической сети. Однако результатом будут не новые правила, включающие переменные, 
  а скорее новые прецеденты, сформированные из старых подстановкой констант.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Рассуждения 
  на основе прецедентов — это, по сути, рассуждения по аналогии, а не логический 
  вывод. Если некто придет к заключению, что Джон, владелец Порше, — водитель, 
  склонный к риску, поскольку имеется прецедент, что Джек, который ездит на Ферра-ри, 
  тоже склонен к риску, то фактически по аналогии делается вывод— Джон похож на 
  Джека, так как автомобиль Порше имеет много общего с Феррари. Напрашивается 
  заключение, что, когда строится такая аналогия, каждый прецедент неявно генерирует 
  определенное правило. В нашем примере такое обобщенное правило состоит в том, 
  что люди, которые ездят на спортивных автомобилях, склонны к риску. Но такое 
  правило не является полным. Все ли водители спортивных машин склонны к риску, 
  или только водители-мужчины, или молодежь? Программа, использующая методику 
  рассуждений на основе прецедентов, не может ответить на такой вопрос. Она способна 
  только отыскать прецедент, наиболее близкий к рассматриваемому случаю.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Между методами 
  CBL и EBG есть и кое-что общее. Оба метода можно противопоставить индуктивным 
  методам, рассмотренным в главе 20, поскольку ни тот ни другой не предполагает 
  анализа большого количества данных. Мы уже показали, что методу EBG достаточно 
  иметь один обучающий экземпляр, а метод CBL для формирования аналогии может 
  обойтись одним подходящим прецедентом.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Но обучение 
  — это нечто большее, чем просто накопление сведений. Система, основанная на 
  анализе прецедентов, должна обладать способностью выявить неподходящие прецеденты, 
  которые не позволяют получить удовлетворительное решение насущной проблемы. 
  В противном случае она будет накапливать прецеденты с ошибочными решениями.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Программа 
  CHEF, описанная в главе 22, способна выявить ситуацию, в которой она формирует 
  неудачный рецепт, и предпринимает попытку исправить его. Чтобы сделать это, 
  программа должна <i>объяснить, </i>почему она полагает рецепт неудачным. Для 
  этого программе требуется воспользоваться определенными знаниями из предметной 
  области, которые в таком случае должны иметь форму правил причинной связи.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Например, 
  модули извлечения и модификации могут предложить замариновать креветок, а потом 
  уже их чистить. Но в этом случае креветки станут слишком влажными, и в рецепте 
  не удастся реализовать заданное в заказе свойство &quot;очищенные креветки&quot;. 
  Программа обнаружит это, когда попытается смоделировать процесс приготовления 
  блюда по созданному рецепту. Тогда другой модуль системы, ответственный за восстановление, 
  обратится к знаниям о типах ошибок в рецептах, отыщет подходящую стратегию исправления 
  ситуации и повторит этап составления рецепта. В новом рецепте сначала нужно 
  очистить креветки, а уже потом их мариновать.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Даже после 
  того, как будет получено решение для нового случая, программа не сможет его 
  правильно индексировать до тех пор, пока не поймет, почему это решение считается 
  успешным. Если пользователь заказывает легкое, нежирное блюдо и если программа, 
  манипулируя прежними рецептами, сформировала новый, то этот результат можно 
  использовать в будущем только после того, как с ним будут ассоциированы признаки 
  &quot;легкий&quot; и &quot;нежирный&quot;.</font></p>
<p>&nbsp;</p><table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index1.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index3.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
</body>
</html>