<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER =0  COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index2.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index4.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
<p>&nbsp;</p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3"><font size="4">2.1.1. 
  Поиск в пространстве состояний</font><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Фундаментальная 
  идея, которая появилась в результате этих первых опытов, получила наименование 
  <i>поиск в пространстве состояний. </i>По существу, идея очень проста. Множество 
  проблем можно сформулировать в терминах трех важнейших ингредиентов:<br>
  </font></p>
<ul>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> исходное состояние 
    проблемы, например исходное состояние головоломки;<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> тест завершения — проверка, 
    достигнуто ли требуемое конечное состояние или найдено решение проблемы (примером 
    может послужить правило определения, собрана ли головоломка);<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> множество операций, 
    которые можно использовать для изменения текущего состояния проблемы, например 
    шаги или перемещения фигур при сборке головоломки.<br>
    </font></li>
</ul>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Один из способов 
  представления такого концептуального пространства состояний — граф, в котором 
  состояниям соответствуют узлы, а операциям — дуги. Рассмотрим в качестве примера 
  задачу построения слова из некоторого множества букв, как в игре Scrabble. Задавшись 
  набором операций установки букв, можно сформировать пространство состояний.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Предположим, 
  что множество доступных букв включает Т, С и А. На каждом уровне графа мы будем 
  добавлять по одной определенной букве. Каждая ветвь, исходящая из узла, соответствует 
  установке буквы в <i>определенную </i>позицию в последовательности, а эта последовательность 
  должна образовать осмысленное слово (рис. 2.1). Если это произошло, то головоломка 
  считается собранной (например, если образовалась комбинация &quot;act&quot; 
  или &quot;cat&quot;). (Сейчас мы не будем стремиться собрать какое-нибудь сложное 
  слово вроде &quot;scrabble&quot;, которое может принести играющему больше очков.)<br>
  </font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif"><img src="1.gif" width="500" height="343"> 
  </font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3">Рис. 2.1. 
  Дерево пространства состояний головоломки Scrabble с буквами Т, С и А<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Это пространство 
  состояний обладает двумя интересными свойствами, которые присущи далеко не всем 
  пространствам состояний:<br>
  </font></p>
<ul>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> оно конечно, поскольку 
    существует только <i>п! </i>способов расставить я букв;<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> оно не содержит повторяющихся 
    узлов, что может привести к образованию петель на графе.<br>
    </font></li>
</ul>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Метод формирования 
  анаграмм последовательным перечислением является примером применения алгоритма, 
  получившего наименование <i>generate-and-test </i>(порождение и проверка).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">(1) <i>Генерировать 
  </i>новое состояние, модифицируя существующее; например, изменить последовательность 
  букв, добавив новую в существующую последовательность.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">(2) <i>Проверить, 
  </i>не является ли образовавшееся состояние конечным (решением); например, проверить, 
  не является ли образовавшаяся последовательность осмысленным словом. Если это 
  так, то завершить, иначе перейти к шагу (1).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Множество 
  решений, которые удовлетворяют условию на шаге (2), иногда называют <i>пространством 
  решений. </i>В некоторых головоломках, например в уже упомянутой &quot;8 ферзей&quot;, 
  решений много, а в других существует всего несколько или только одно. Действительно, 
  существует довольно много способов разместить восемь ферзей на шахматной доске 
  так, чтобы ни один из них не оказался под боем, а вот для головоломки &quot;8-Puzzle&quot; 
  существует единственное решение (см. упр. 7).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Алгоритм имеет 
  два основных варианта: <i>поиск в глубину (depth-first search) </i>и <i>поиск 
  в ширину (breadth-first search). </i>Отличаются варианты порядком формирования 
  состояний на шаге (1). Действительные алгоритмы приведены в упр. 5, а здесь 
  мы дадим только их неформальное описание.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Для любого 
  данного узла <i>N </i>алгоритм поиска в глубину строит потомок этого узла, т.е. 
  формирует состояние, которое образуется в результате применения операторов к 
  узлу <i>N, </i>а потом переходит к формированию узла, ближайшего к <i>N, </i>на 
  том же уровне графа (&quot;соседу&quot; <i>N), </i>т.е. формирует состояние, 
  которое образуется в результате применения оператора к узлу-родителю <i>N. </i>Алгоритм 
  поиска в ширину действует наоборот — сначала формируются все &quot;соседи&quot; 
  узла <i>N, </i>а потом уже строятся его потомки. Таким образом, в алгоритме 
  поиска в ширину просматриваются последовательно состояния, представленные узлами 
  одного и того же уровня на графе (рис. 2.2), а в алгоритме поиска в глубину 
  просматриваются состояния на одном пути, а затем происходит возврат назад на 
  один уровень и формируется следующий путь (рис. 2.3).<br>
  </font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif"><img src="2.gif" width="500" height="347"> 
  </font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3">Рис. 2.2. 
  Граф пространства состояний при использовании алгоритма поиска в ширину<br>
  </font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif"><img src="3.gif" width="500" height="339"> 
  </font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3">Рис. 2.3. 
  Граф пространства состояний при использовании алгоритма поиска в глубину</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">На обоих рисунках 
  числа на дугах графа указывают номер шага, на котором формируется тот узел (состояние), 
  для которого эта дуга является входящей. Конечно, этот номер еще зависит и от 
  того, в каком порядке используются операторы из имеющегося множества. В представленном 
  примере сначала применяется оператор, добавляющий очередную букву в конец последовательности, 
  затем оператор, добавляющий букву на предпоследнюю позицию, и т.д., а последним 
  применяется оператор, добавляющий букву на первое место. Но ведь можно использовать 
  и обратный порядок применения операторов.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Оба алгоритма 
  завершат работу (найдут конечное состояние) после формирования узла &quot;act&quot;, 
  а не &quot;cat&quot;. Но алгоритму поиска в ширину придется для этого &quot;посетить&quot; 
  пять узлов (сформировать и проанализировать пять состояний), а алгоритму поиска 
  в глубину — четыре.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Отметим, что 
  свойства этих алгоритмов существенно отличаются.<br>
  </font></p>
<ul>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> Алгоритм поиска в ширину 
    отыскивает решение, путь к которому на графе — кратчайший, если таковое существует. 
    Другими словами, он находит кратчайший путь между исходным состоянием и решением. 
    Алгоритмы, обладающие таким свойством, называются <i>разрешимыми (admissible).</i><br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> Алгоритм поиска в глубину 
    может быстрее найти решение, особенно, если при его выполнении используются 
    эвристики для выбора очередной ветви. Но этот алгоритм может никогда не закончиться, 
    если пространство состояний бесконечно.<br>
    </font></li>
</ul>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Нетрудно заметить, 
  что число узлов растет экспоненциально по мере увеличения числа уровней на графе. 
  Это явление часто называют <i>комбинаторным взрывом </i>и оно представляет очень 
  серьезную проблему при программировании таких задач, например при &quot;грубом&quot; 
  переборе всех возможных вариантов позиций в игре в шахматы (см. врезку 2.1). 
  Поскольку человеческий мозг слабее компьютера при решении задач, связанных с 
  перебором вариантов, естественно предположить, что серьезный шахматист решает 
  эту задачу каким-то другим способом. Скорее всего он использует свой опыт, воображение 
  и аналитические способности, во-первых, для формирования общей стратегии игры, 
  а во-вторых, для выбора наилучшего очередного хода. Вот такой-то способ решения 
  мы и называем &quot;интеллектуальным&quot;, в отличие от &quot;грубого перебора&quot;.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В игровых 
  программах также используется поиск в пространстве состояний, но стратегия поиска 
  более избирательна, чем в случае прямого применения алгоритма <i>generate-and-test. 
  </i>Кроме того, нужно принимать во внимание и то, что в игре, как правило, принимают 
  участие две противоборствующие стороны. Были разработаны довольно неплохие программы 
  для игры в шашки, нарды и шахматы. Созданные программы игры в шахматы нельзя 
  отнести к классу систем, основанных на знаниях, а скорее к классу программ, 
  обладающих способностью избирательно анализировать пространство состояний, что 
  значительно повышает скорость и эффективность анализа. Методы и алгоритмы этого 
  класса в данной книге рассматриваться не будут.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Другая задача, 
  которая занимала умы исследователей в области искусственного интеллекта в середине 
  50-х годов, — <i>доказательство теорем. </i>Смысл задачи доказательства состоит 
  в том, чтобы показать, как некоторое утверждение, которое требуется доказать 
  <i>(теорема), </i>логически следует из декларированного множества других утверждений 
  или <i>аксиом </i>(которые <i>полагаются </i>истинными <i>или являются </i>такими 
  априори).<br>
  </font></p>
<p align="center"> <font face="Arial, Helvetica, sans-serif" size="3"><b><font color="#666666">2.1. 
  Комбинаторный взрыв</font></b><font color="#666666"><br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Исследованием 
  вычислительной <i>обозримости </i>(или <i>необозримости) </i>проблем занимается 
  <i>теория сложности. </i>Для начала нам потребуется только знать, что существуют 
  классы проблем, решение которых требует ресурсов, <i>экспоненциально </i>возрастающих 
  при <i>линейном </i>увеличении размерности задачи. Например, время, необходимое 
  для отыскания пути в лабиринте, экспоненциально увеличивается при увеличении 
  количества разветвлений в лабиринте. Аналогично, время, необходимое для поиска 
  доказательства теоремы исчислением утверждений, растет экспоненциально по отношению 
  к количеству переменных. Такие проблемы являются в общем случае необозримыми 
  и называются <i>NP-hard. </i>Читателей, которые ими заинтересуются, мы отсылаем 
  к специальной литературе, в частности книге Хопкрофта и Ульмана <i>[Hopcroft 
  and Ullman, 1979].</i><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Проблемы, 
  время решения которых связано с размерностью задачи полиномиальной функции, 
  считаются обозримыми. Например, проверка заданного маршрута в лабиринте или 
  проверка правильности доказательства некоторой теоремы — обозримые проблемы. 
  Но можно показать, что, к сожалению, большинство проблем, которые интересуют 
  нас в области искусственного интеллекта, относятся к классу <i>NP-hard. </i>Поэтому 
  такое важное значение придается использованию эвристических методов при их решении.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Прекрасное 
  изложение теории вычислительной сложности, рассчитанное на читателя, несклонного 
  к излишнему теоретизированию, можно найти в работе Паунд-стоуна <i>[Poundstone, 
  1988, Chapter 9].</i><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Рассмотрим 
  такой пример. Пусть имеются две аксиомы, представленные на некотором формальном 
  языке:<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">&quot;Если 
  компьютер может ошибаться, он ошибется&quot; и<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">&quot;Мой 
  компьютер может ошибаться&quot;.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Тогда, 
  используя механизм исчислений только правил влияния, мы можем показать, что 
  справедлива теорема.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">&quot;Мой 
  компьютер ошибется&quot;.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Это 
  утверждение логически следует из заданных аксиом в том смысле, что оно не может 
  быть ложным, если истинны исходные утверждения (аксиомы). Корректности такого 
  следствия легко доказываются компьютером — все, что от него требуется, так это 
  обработать выражения в форме логической зависимости:<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">(любой 
  Х)(F(X)) <img src="prinadl.gif" width="9" height="10"> G(X))<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">F(a) 
  / [G(a){X/a}]<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">которое 
  читается следующим образом:<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">&quot;Все 
  элементы <i>F </i>являются элементами <i>G, а </i>входит в <i>F, </i>следовательно, 
  <i>F </i>есть G&quot;.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Как 
  и в случае с головоломками, некоторые концепции и методы, разработанные в области 
  машинного доказательства теорем (иногда эту область исследований называют <i>automated 
  reasoning </i>— <i>машинным поиском логического вывода), </i>весьма помогут 
  студентам при решении практических проблем. Итак, знания, касающиеся решения 
  некоторой проблемы, можно представить как набор аксиом, т.е. <i>теорию, </i>а 
  процесс поиска решения проблемы можно рассматривать как попытку доказать <i>теорему, 
  </i>каковой является искомое решение (подробнее об этом — в главе 8). Другими 
  словами, поиск решения среди сформулированных теорем аналогичен поиску пути 
  на графе в пространстве состояний и для его анализа можно использовать тот же 
  аппарат.</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">К сожалению, 
  процесс порождения всех возможных теорем, вытекающих из заданного множества 
  аксиом, имеет все черты комбинаторного взрыва, поскольку на основе <i>первичных 
  </i>теорем, непосредственно вытекающих из аксиом, можно сформулировать новое 
  множество теорем и т.д. Поиск решения посредством доказательства теорем может 
  повлечь за собой такое количество вычислений, с которым не справится никакой 
  мыслимый компьютер, и можно доказать, что некоторые из таких вычислений даже 
  теоретически никогда не смогут завершиться. В области машинного поиска логического 
  вывода существенные успехи достигнуты в направлении, которое связано с генерацией 
  формальных математических доказательств, но эти методы с трудом приложимы к 
  менее формализованным областям. Поскольку большинство человеческих особей не 
  обладают выдающимися способностями в области построения логических выводов, 
  да еще принимая во внимание комбинаторные сложности, вряд ли стоит рассчитывать 
  на существенное влияние участия человека в формальных рассуждениях такого рода. 
  Скорее помощь может проявиться в том, что человек сможет делать более правдоподобные 
  предположения или порождать более вероятные гипотезы, носящие неформальный характер. 
  Это именно тот вид заключений, который используется при моделировании путей 
  поиска решения реальных проблем в экспертных системах.<br>
  </font></p>
<p>&nbsp;</p><table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index2.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index4.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
</body>
</html>