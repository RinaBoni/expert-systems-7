<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index3.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index5.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
<p>&nbsp;</p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3"><font size="4">2.1.2. 
  Эвристический поиск</font><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Поскольку 
  слепой поиск возможен только в небольшом пространстве вариантов, напрашивается 
  совершенно естественный вывод, что необходим некоторый способ направленного 
  поиска. Если такой способ использует при поиске пути на графе в пространстве 
  состояний некоторых знаний, специфических для конкретной предметной области, 
  его принято называть <i>эвристическим поиском. </i>Лучше всего рассматривать 
  эвристику в качестве некоторого правила влияния, которое, хотя и не гарантирует 
  успеха (как детерминированный алгоритм или процедура принятия решения), в большинстве 
  случаев оказывается весьма полезным.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Простая форма 
  эвристического поиска — это <i>восхождение на гору. </i>В процессе поиска в 
  программе использует некоторая <i>оценочная функция, </i>с помощью которой можно 
  грубо оценить, насколько &quot;хорошим&quot; (или &quot;плохим&quot;) является 
  текущее состояние. Затем можно применить ту же функцию для выбора очередного 
  шага, переводящего систему в следующее состояние.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Например, 
  простая оценочная функция для программы игры в шахматы может включать очевидную 
  оценку материала (количества и качества имеющихся на доске фигур) — своего и 
  соперника. Затем программа перебирает возможные операторы перехода в новое состояние 
  (возможные ходы фигур) и, сравнивая результаты вариантов, отыскивает такой, 
  который характеризуется максимальным значением оценочной функции. Другими словами, 
  ищется такой ход, который дает наибольший материальный выигрыш.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Основной алгоритм, 
  реализующий идею восхождения на гору, можно сформулировать следующим образом.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">(1) Находясь 
  в данной точке пространства состояний, применить правила порождения нового множества 
  возможных решений, например множества ходов фигур, допустимых в данной позиции.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">(2) Если одно 
  из новых состояний является решением проблемы, прекратить процесс. В противном 
  случае перейти в то состояние, которое характеризуется наивысшим значением оценочной 
  функции. Вернуться к шагу (1).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Но применение 
  этого подхода наталкивается на хорошо известные трудности. Главная из них — 
  как сформулировать оценочную функцию, которая адекватно бы отражала &quot;качество&quot; 
  текущего состояния. Продолжая наш пример с игрой в шахматы, заметим, что иметь 
  много фигур, больше чем у соперника, отнюдь не значит иметь лучшую позицию, 
  т.е. быть ближе к успеху. Такая простая оценочная функция не учитывает многих 
  особенностей этой игры (а в более широком контексте — особенностей данной предметной 
  области).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Более того, 
  даже если оценочная функция и позволяет адекватно оценить текущую ситуацию, 
  сущестЬуют разнообразные ситуации игры, которые сами по себе могут быть источником 
  затруднений. Например, в данном состоянии нет очевидного очередного хода, т.е. 
  оказывается, что все возможные ходы одинаково хороши (или плохи). Это не что 
  иное, как выход на &quot;плато&quot; в нашем восхождении, когда ни один из возможных 
  путей не влечет за собой подъем. Другой возможный источник затруднений — наличие 
  <i>локальных максимумов, </i>из которых возможен только спуск, т.е. &quot;ухудшение&quot; 
  состояния. Например, я могу взять вашего ферзя и после этого проиграть партию.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Лучшими свойствами 
  обладает другая форма эвристического поиска, которая получила наименование <i>сначала 
  наилучший (best-first search). </i>Так же, как и в варианте <i>восхождения на 
  гору, </i>в нашем распоряжении имеется оценочная функция, с помощью которой 
  можно сравнивать состояния в пространстве состояний. Основное же отличие нового 
  метода от ранее рассмотренного состоит в том, что сравниваются не только те 
  состояния, в которые возможен переход из текущего, но и <i>все, </i>до которых 
  &quot;можно достать&quot;.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Такой алгоритм, 
  естественно, требует значительно больших вычислительных ресурсов, но идея состоит 
  в том, чтобы принимать во внимание не только ближайшие состояния, т.е. локальную 
  обстановку, а &quot;окинуть взглядом&quot; как можно больший участок пространства 
  состояний и быть готовым, в случае необходимости, вернуться туда, где мы уже 
  были, и пойти другим путем, если ближайшие претенденты не сулят существенного 
  прогресса в достижении цели (см. описание алгоритма А во врезке 2.2). Вот эта 
  возможность отказаться от части пройденного пути во имя глобальной цели и позволяет 
  найти более эффективный путь. Необходимость хранить ранее сделанные оценки состояний 
  и постоянно их обновлять, конечно, требует значительных вычислительных ресурсов.<br>
  </font></p>
<p align="center"> <font face="Arial, Helvetica, sans-serif" size="3"><b><font color="#666666">2.2. 
  Алгоритм А</font></b><font color="#666666"><br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Существует 
  хорошо известный алгоритм поиска, который относится к группе первый <i>лучший, 
  </i>получивший наименование А (произносится &quot;А со звездочкой&quot;). Основная 
  идея алгоритма состоит в использовании для каждого узла п на графе пространства 
  состояний оценочной функции вида<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666"><i>f(n) 
  = g(п) </i>+ <i>h(n).</i><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Здесь 
  g<i>(п) </i>соответствует расстоянию на графе от узла <i>п </i>до начального 
  состояния, a <i>h(n) </i>—оценка расстояния от <i>п </i>до узла, представляющего 
  конечное (целевое) состояние. Чем меньше значение оценочной функции <i>f(n), 
  </i>тем &quot;лучше&quot;, т.е. узел <i>п </i>лежит на более коротком пути от 
  исходного состояния к целевому. Идея алгоритма состоит в том, чтобы с помощью 
  <i>f(n) </i>отыскать кратчайший путь на графе от исходного состояния к целевому.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Отсюда 
  следует, что если <i>h(n) </i>— нижняя оценка <i>действительного </i>расстояния 
  до целевого состояния, т.е. если <i>h(n) </i>никогда не дает завышенной оценки 
  расстояния, то алгоритм А всегда отыщет оптимальный путь до цели при помощи 
  оценочной функции <i>f(n). </i>Алгоритм, обладающий таким свойством, называется 
  разрешимым (более подробное обсуждение этого вопроса читатель найдет в специальной 
  литературе, в частности в работах <i>Нмпьсона [Nilsson, 1980, Chapter 2] </i>и 
  Перла <i>[Pearl, 1984, Chapter 2]).</i><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666"><b>Обозначения:</b><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">s 
  — узел начального состояния;<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666"><i>g</i>— 
  узел целевого состояния;<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">OPEN 
  — список, который содержит,выбранные, но необработанные узлы;<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">CLOSED 
  — список, который содержит обработанные узлы.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666"><b>Алгоритм</b><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">(1) 
  OPEN:={s}.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">(2) 
  Если ОРЕМ:={}, то прекратить выполнение. Пути к целевому состоянию на графе 
  не существует.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">(3) 
  Удалить из списка OPEN узел п, для которого <i>f(n)&lt;f(m) </i>для любого узла 
  <i>т, </i>уже присутствующего в списке OPEN, и перенести его в список CLOSED.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">(4) 
  Сформировать список очередных узлов, в который возможен переход из узла n и 
  удалить из него все узлы, образующие петли; с каждым из оставшихся связать указатель 
  на узел п.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">(5) 
  Если в сформированном списке очередных узлов присутствует <i>д, </i>то завершить 
  выполнение. Сформировать результат — путь, порожденный прослеживанием указателей 
  от узла <i>д </i>до узла s.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">(6) 
  В противном случае для каждого очередного узла n', включенного в список, выполнить 
  следующую последовательность операций.<br>
  </font></p>
<ul>
  <li> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666"> Вычислить 
    <i>f(n').</i><br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666"> Если 
    n не присутствует ни в списке OPEN, ни в списке CLOSED, добавить его в список, 
    присоединить к нему оценку <i>f(n') </i>и установить обратный указатель на 
    узел <i>п.</i><br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Если 
    n' уже присутствует в списке OPEN или в списке CLOSED, сравнить новое значение 
    <i>f(n)=new </i>с прежним <i>f(n')=old.</i><br>
    </font></li>
</ul>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Если 
  <i>old&lt;new, </i>прекратить обработку нового узла.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Если 
  <i>new&lt;old, </i>заменить новым узлом прежний в списке, причем, если прежний 
  узел<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">был 
  в списке CLOSED, перенести его в список OPEN.<br>
  </font></p>
<p align="center"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666"><b>Конец 
  алгоритма</b></font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Применение 
  этого алгоритма рассмотрено в упр. 8.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Вычислительная 
  мощность современных компьютеров все-таки недостаточна для того, чтобы использовать 
  алгоритмы поиска решений даже с помощью направленного поиска с применением оценочной 
  функции, не говоря уже о методике слепого перебора возможных состояний. Пространство 
  состояний, в котором нужно вести поиск, при решении таких задач, как распознавание 
  речи, выбор конфигурации компьютерной системы или планирование последовательности 
  операций, настолько велико, что его невозможно проанализировать такими обобщенными 
  методами за обозримый отрезок времени, если только не призвать на помощь знания, 
  касающиеся конкретной предметной области. Можно показать, что многие из этих 
  проблем изоморфны абстрактным задачам, которые заведомо относятся к классу &quot;необозримых&quot; 
  в том смысле, что их сложность, а соответственно и потребность в вычислительных 
  ресурсах, экспоненциально возрастает при линейном увеличении размерности задачи.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Как будет 
  показано далее, развитие экспертных систем пошло по пути привлечения опыта экспертов, 
  как касающегося деталей поведения конкретных объектов в конкретной ситуации, 
  так и стратегии логического вывода в определенной предметной области, что и 
  позволяет преодолеть трудности, связанные со сложностью формализованного поиска 
  в пространстве состояний.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Достаточно 
  подробно результаты первых исследований в области программирования игр и машинного 
  доказательства теорем описаны в сборнике статей под редакцией Фей-генбаума и 
  Фельдмана <i>[Feigenbaum and Feldman, 1963]. </i>Я склонен к тому, чтобы считать 
  &quot;классическим&quot; в истории искусственного интеллекта период, который 
  начался с публикации в 1950 году статьи Шеннона об игре в шахматы <i>[Shannon, 
  1950] </i>и закончился выходом сборника Фейгенбаума и Фельдмана. Наиболее существенные 
  результаты, полученные в этот период, можно сформулировать следующим образом:<br>
  </font></p>
<ul>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> проблему любой сложности, 
    в принципе, можно свести к проблеме поиска в пространстве состояний, если 
    только удается ее формализовать в терминах начального состояния, конечного 
    состояния и операций перехода в пространстве состояний;<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> поиск в пространстве 
    состояний должен направляться определенным образом представленными знаниями 
    о конкретной предметной области.<br>
    </font></li>
</ul>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Очень редко 
  удается свести использование знаний к формулировке адекватной оценочной функции 
  и таким образом помочь программе оценить свое поведение в текущей ситуации и 
  найти правильный путь к решению. Но в большинстве случаев требуется нечто большее, 
  что-то вроде глобальной стратегии решения проблем или явного использования знаний 
  об объектах, их свойствах и связанных с ними действиях в конкретной предметной 
  области, или комбинации того и другого.</font></p>
<p>&nbsp;</p><table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index3.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index5.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
</body>
</html>