<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index8.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index10.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
<p>&nbsp;</p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3"><font size="4">2.3.1. 
  В знании сила</font><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В период модернизма 
  возросла уверенность, что эвристические возможности &quot;решателя&quot; проблем 
  определяются представлением в явной форме соответствующих зданий, доступных 
  программе, а не применением какого-то изощренного механизма определения взаимовлияния 
  или сложных оценочных функций. Значительные усилия были направлены на разработку 
  методов разбиения знаний, присущих человеку, на модули, которые можно было бы 
  активизировать по заданной схеме (см. врезку 2.5). Уже при первых попытках сымитировать 
  процесс разрешения проблем, характерный для человеческого разума (например, 
  в работе <i>[Newell and Simon, 1972]), </i>исследователи столкнулись с ограниченными 
  возможностями представления знаний и необходимостью упростить механизм их взаимовлияний, 
  хотя более поздние исследования и помогли в определенной степени преодолеть 
  эти трудности (об этом мы поговорим в главах 11-18).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Стало ясно, 
  что стратегия явного представления человеческого знания в форме направляемых 
  заданной схемой модулей обладает определенными преимуществами перед включением 
  знаний в алгоритм, которые могут быть реализованы с помощью программных технологий, 
  более близких к традиционным.<br>
  </font></p>
<ul>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> Процесс воспроизведения 
    явных знаний, напоминающий кулинарный рецепт, потенциально обещает более чувствительный 
    механизм настройки соответственно тому, как эксперт хранит и применяет имеющиеся 
    у него знания. Редко кто из экспертов может представить четко сформулированную 
    последовательность операций, гарантирующую успешное завершение процедуры в 
    любой ситуации, в ответ на вопрос о том, как он действует в процессе решения 
    проблемы. Скорее знания, которыми обладает эксперт, извлекаются по мере выяснения, 
    как поступать в типичных ситуациях, а затем к ним прибавляются исключения 
    из таких ситуаций.<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> Такой метод программирования 
    знаний создает предпосылки для довольно быстрого создания прототипа системы 
    и последующего ее постепенного развития. Если конструктор системы и программист 
    справились со своей работой должным образом, созданную в результате программу 
    несложно модифицировать и функционально расширить. Ошибки и провалы, обнаруженные 
    в процессе эксплуатации в заложенных в систему знаниях, могут быть скорректированы 
    и заполнены, причем это не влечет за собой кардинальную переделку основного 
    программного кода. Если же в структуре системы не предусмотрена такая &quot;модульность&quot; 
    знаний, их изменения могут повлечь за собой полную реконструкцию системы.<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> Большинство из тех, 
    кто работали с практическими программами решения проблем, пришли к выводу, 
    что полезной может быть и программа, которая не решает проблему целиком или 
    не бывает права абсолютно всегда. Экспертная система может функционировать 
    и как &quot;разумный ассистент&quot;, который предлагает несколько альтернативных 
    вариантов решения проблемы и отвергает менее приемлемые.<br>
    </font></li>
</ul>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В этот период 
  разработчики на практике убедились в том, как сложно создавать и отлаживать 
  системы, базирующиеся на правилах. По мере расширения базы знаний оказалось, 
  что правила имеют тенденцию взаимодействовать в пределах системы самым неожиданным 
  образом, соревнуясь за приоритет при решении проблемы, что разные режимы управления 
  правилами эффективны для проблем одного типа и не дают эффекта при решении проблем 
  другого типа. Со временем в этом перестали видеть что-то необычное, но поначалу 
  свидетельства такого эффекта воспринимались как анекдоты.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Практический 
  опыт научил нас, что наилучшие результаты при решении проблем разного рода можно 
  получить, только используя отличающиеся методики. Эти методики, получившие звучные 
  и исполненные тайного смысла наименования &quot;эвристическая классификация&quot;, 
  &quot;иерархическая проверка гипотез&quot; и &quot;предложение, проверка и исправление&quot;, 
  как правило, сводятся к разным стратегиям управления последовательностью применения 
  правил. Эти методики будут подробно рассмотрены в главах 11-15.<br>
  </font></p>
<p align="center"> <font face="Arial, Helvetica, sans-serif" size="3"><b>2.5. 
  Процедуральное или декларативное знание</b><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В процедурных 
  языках программирования, таких как С, мы, как правило, физически не разграничиваем 
  ту часть программы, которая описывают ее &quot;логику&quot;, от той, которая 
  имеет дело с манипулированием данными. Например, процедура, в которой проверяется, 
  обладает ли данная птица способностью летать, будет выглядеть так:<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">char 
  fly(char s)<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">{<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">char 
  answer = 'д'; if (strcmpfs, &quot;пингвин&quot;)==0) </font></p>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">{ 
  answer = 'н';} return answer; </font></p>
<p align="left"><font face="Verdana, Arial, Helvetica, sans-serif" size="3">}<br>
  </font><font face="Arial, Helvetica, sans-serif" size="3"> </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Независимо 
  от того, владеете вы языком С или нет, понятно, что этот программный код явно 
  вызывается другой частью программы, например, так:<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">char 
  с;<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">с 
  = fly(&quot;пингвин&quot;);<br>
  </font><font face="Arial, Helvetica, sans-serif" size="3"> </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Предположим, 
  что вместо этого у нас есть два правила, которые хранятся в базе знаний:<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(defrule<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(птица 
  (тип ?Х)) =&gt;<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(assert 
  (да))<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">)<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(defrule<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(птица 
  (тип пингвин)) =&gt; <br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(assert 
  (нет)) )</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В этом примере 
  форма правил более близка к объявлению или определению (использован- синтаксис 
  языка CLIPS). Для случайно выбранной птицы утверждается, что она способна летать. 
  Но если известно, что птица — это пингвин, то утверждается, что она не способна 
  летать. Но поскольку пингвин это тоже птица, то какой-то другой компонент экспертной 
  системы должен решить, какое из этих двух правил применять в данной ситуации. 
  Этот компонент называется <i>машиной логического вывода (inference engine).</i><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3"><i>В </i>этом 
  примере совершенно отчетливо видна модульная природа правил. Код, который в 
  явном виде <i>вызывает </i>то или иное правило, отсутствует. Подробно реализация 
  таких правил будет рассмотрена в главе 5.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В этот период 
  появился ряд систем, которые довольно эффективно справлялись с нетривиальными 
  задачами. Примером может служить система R1/XCON, предназначенная для структурного 
  синтеза вычислительных систем (подробно о ней — в главе 14). В этой системе 
  реализован ряд концепций, существенно отличающих ее как от обычных программных 
  приложений, так и от исследовательских программ искусственного интеллекта (см. 
  <i>[Davis, 1982]). </i>Те, которые я считаю наиболее важными, перечислены ниже.<br>
  </font></p>
<ul>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> Как уже было подчеркнуто 
    в главе 1, часть программы, которая содержит представление знаний, касающихся 
    определенной предметной области, — <i>база знаний, </i>как правило, отделена 
    от той части программы, которая занимается формулировкой соображений, — <i>машины 
    логического вывода. </i>Такое разделение позволяет вносить изменения (конечно, 
    в разумных пределах) в одну часть программы, не меняя другой. В частности, 
    можно добавлять в базу знаний новую информацию, расширяя имеющиеся в системе 
    знания, или настраивать механизм логического вывода, повышая его эффективность, 
    и при этом не модифицировать программный код системы.<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> С точки зрения пользователя 
    систем такого рода желательно, чтобы в них использовалась единая форма представления 
    знаний, насколько это вообще возможно в системах разного назначения. Это упрощает 
    процесс ввода знаний в систему, облегчает обслуживающему персоналу сопровождение 
    системы и препятствует излишнему усложнению машины логического вывода. Однако, 
    как будет показано в главе 11 и последующих, единообразие может привести к 
    возникновению определенных трудностей при попытке &quot;втиснуть&quot; самые 
    разные по своей естественной природе знания в один и тот же формализм. Таким 
    образом, в вопросе о представлении знаний существует определенная &quot;золотая 
    середина&quot; между крайностями — полным единообразием и узкоспециализированным 
    формализмом.<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> Помимо найденного решения 
    проблемы, экспертная система должна предоставить пользователю еще и информацию 
    о том, как это решение было получено. Этим она существенно отличается от большинства 
    привычных программных приложений. При использовании простой машины логического 
    вывода и определенного формализма представления знаний такое объяснение включает 
    перечень модулей базы знаний, задействованных в процессе принятия решения, 
    и информацию о том, в каком порядке они активизировались. В главе 16 будет 
    показано, как это выглядит на практике, и вы сможете убедиться, что эта информация 
    не всегда соответствует нашим ожиданиям по части полноты и что желательно 
    в этой области изобрести какую-нибудь более информативную технологию.<br>
    </font></li>
</ul>
<p align="center"> <font face="Arial, Helvetica, sans-serif" size="3"><b>2.6. 
  Машина логического вывода и база знаний</b><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Как правило, 
  в структуре экспертной системы можно четко разделить базу знаний и компонент, 
  который этой базой пользуется, — машину логического вывода. Взаимодействие между 
  ними обеспечивается программой, которую принято называть оболочкой (shell) экспертной 
  системы. Конечный пользователь приложения взаимодействует с системой через оболочку, 
  передавая ей запросы. Последняя активизирует машину логического вывода, которая 
  обращается к базе знаний, извлекает знания, необходимые для ответа на конкретный 
  вопрос, и передает сформированный ответ пользователю либо как решение проблемы, 
  либо в форме рекомендации или совета (рис. 2.5).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В базе данных 
  содержатся правила и всевозможные декларации. В частности, применительно к примеру 
  &quot;Пингвин&quot;, представленному во врезке 2.5, в базе знаний, организованной 
  с помощью языка CLIPS, должны присутствовать следующие декларации:<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(deftemplate 
  птица (field (тип SYMBOL)))<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">в 
  дополнение к имеющимся правилам:<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(defrule 
  (птица (тип ?Х))<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">=&gt;<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(assert 
  (да))<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">)<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(defrule<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(птица 
  (тип пингвин))<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">=&gt;<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(assert 
  (нет)) )</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Из этой декларации 
  следует, что объект данных птица может содержать поле (field) тип. В главе 5 
  вы познакомитесь с декларациями другого типа, которые служат для настройки поведения 
  машины логического вывода.<br>
  </font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif"><img src="5.gif" width="500" height="218"> 
  </font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3">Рис. 2.5. 
  Структура экспертной системы</font></p>
<p>&nbsp;</p><table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index8.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index10.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
</body>
</html>