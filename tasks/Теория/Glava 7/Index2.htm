<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index1.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index3.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
<p>&nbsp;</p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3"><b><font size="4">7.1. 
  Язык KRL</font></b><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В языке KRL 
  впервые была сделана попытка собрать воедино результаты выполненных ранее исследований 
  о структурировании элементов знаний и реализовать их в виде единой системы <i>[Bobrow 
  and Winograd, 1977]. </i>Создание системы преследовало не только теоретические 
  цели, но и имело достаточно четкую практическую направленность. В качестве &quot;строительных 
  блоков&quot; системы использованы так называемые &quot;концептуальные объекты&quot;, 
  которые были сходны с фреймами, предложенными Минским, в том, что представляют 
  прототипы и связанные с ними свойства. Основную идею авторы так изложили в опубликованной 
  в 1977 году статье:<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666"><b>&quot;...анализ 
  последствий объектно-центрической факторизации знаний в противовес более общей 
  факторизации, предполагающей структурирование знаний в виде набора фактов, каждый 
  из которых ссылается на один или несколько объектов&quot;.</b></font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Такая ориентация 
  повлекла за собой создание декларативного языка, основанного на описаниях, в 
  которых концептуальные объекты рассматриваются не изолированно, а в совокупности 
  с другими объектами-прототипами. Фундаментальное предположение состояло в том, 
  что то, какие свойства некоторого объекта знаний оказываются существенными, 
  представляющими интерес и т.д., зависит от точки зрения на объект и цели решаемой 
  задачи. Например, если вам нужно сыграть музыкальную пьесу на пианино, то вас 
  интересуют такие свойства этого объекта, как качество звучания, настройки и 
  т.п. А вот грузчику более интересны такие свойства этого музыкального инструмента, 
  как вес и габариты.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В этом свете 
  описание новой сущности можно рассматривать как процесс сравнения ее с ранее 
  описанными: нужно указать, на какие из известных объектов похож новый и чем 
  именно, а в чем от них отличается. Так, мини-фургон очень похож на легковой 
  автомобиль, но отличается от последнего отсутствием сидений для пассажиров и 
  окон в задней части. Другими словами, полный набор понятий можно определить 
  в терминах друг друга, а не в терминах более компактного множества примитивных 
  идей. Сложность с использованием примитивов в представлении семантики состоит 
  в том, что вряд ли когда-нибудь удастся прийти к единому мнению о том, что же 
  представляют собой такие примитивные понятия и как их следует комбинировать 
  при формировании более сложной идеи (с некоторыми соображениями на сей счет 
  читатель может ознакомиться в работах <i>[Schank, 1975] </i>и <i>[Schank andAbelson, 
  1977]).</i><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В основе процедурных 
  свойств языка KRL также лежат наиболее распространенные программные методы, 
  предполагающие подключение процедур общего вида к классам объектов данных. Бобров 
  и Виноград объединили этот вид подключения процедур со структурой фрейма и позволили 
  подклассам наследовать как процедуры, так и данные своего суперкласса.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Разработчики 
  языка предположили, что наследование процедур позволит программировать в терминах 
  <i>родовых операций, </i>детали реализации которых конкретизируются по-разному 
  для объектов разных классов. Так же, как абстрактные типы данных позволяют программисту 
  забыть о деталях хранения конкретных данных в машине, так и родовые операции 
  позволяют на определенной стадии не принимать во внимание детали реализации 
  однотипных операций в каждом конкретном случае. Пример поможет вам четче представить 
  смысл этой идеи.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Предположим, 
  вас назначили Верховным главнокомандующим при проведении военной операции, в 
  которой принимают участие различные рода войск. Отданные в ваше распоряжение 
  танки, корабли и самолеты ждут приказа атаковать. Получив такой приказ, каждый 
  из родов войск будет действовать по-своему: самолеты начнут бомбить, корабли 
  — выпускать ракеты и т.д. Но поведение каждого из родов войск — это частная 
  реализация общей концепции наступательных военных действий. Как главнокомандующего, 
  вас мало интересуют детали выполнения приказа: на какие рычаги нажимать, какие 
  переключатели включать, — все это должно быть определено на более низких уровнях.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Возвращаясь 
  вновь к KRL, отметим, что идея, которая стоит за объектно-центрической организацией 
  процедур, состоит в том, чтобы попытаться программно воспроизвести тот естественный 
  стиль выработки суждений, который реализуется в мозге человека. В частности, 
  предполагается, что управление логическим выводом реализуется на локальном уровне, 
  в отличие от глобальных задач, ассоциирующихся, например, с автоматическим доказательством 
  теорем. Другими словами, зная, как реализовать родовые операции, классы объектов 
  будут обладать знаниями и о том, <i>когда активизировать те </i>многочисленные 
  процедуры, к которым они имеют доступ.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Мы не затрагивали 
  многих других аспектов языка KRL, например средств управления процессом или 
  составления расписаний работ. Читателям, интересующимся этим языком, рекомендуем 
  познакомиться с критическим анализом этого языка, который выполнили Ленерт и 
  Уилкс <i>[Lehnert and Wilks, 1979], </i>и ответом разработчиков на эти критические 
  замечания <i>[Bobrow and Winograd, 1979]. </i>Нельзя не отметить, что язык KRL 
  явился тем локомотивом, который существенно подтолкнул исследования в области 
  теории представления знаний и, в частности, способствовал появлению практических 
  систем, о которых речь пойдет в следующем разделе.<br>
  </font></p>
<p align="center"> <font face="Arial, Helvetica, sans-serif" size="3"><b><font color="#666666">7.1. 
  Процедуры и объекты</font></b><font color="#666666"><br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">На 
  рис. 7,1 мы попытались схематически представить, в чем основная разница между 
  процедурно- и объектно-ориентированным подходами в программировании.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">Серые! 
  эллипсы на схеме в левой части рисунка представляют процедуры, некоторые из 
  которых напрямую обращаются к данным, хранящимся в файле или в базе данных. 
  Зачерненный эллипс представляет процедуру самого верхнего уровня (в языке С 
  — это процедура main). Эта функция вызывает другие функции, которые в конце 
  концов вызывают функции самого нижнего уровня, выполняющие операции ввода/вывода.<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">На 
  правой схеме объекты объединяют данные и процедуры работы с ними. Объекты организованы 
  в виде одной или нескольких иерархических структур — деревьев или решеток. Утолщенный 
  прямоугольник на схеме представляет базовый абстрактный класс. Экземпляры этих 
  объектов взаимодействуют друг с другом, обмениваясь сообщениями, и таким образом 
  образуются связи, ортогональные иерархии наследования.</font><font size="3"></font></font><font face="Arial, Helvetica, sans-serif"><i><font size="3"><br>
  </font></i></font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif"><img src="1.gif" width="550" height="313"> 
  </font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif"><font size="3">Рис. 
  7.1. Процедурно- и объектно-ориентированные парадигмы программирования. Незаполненные 
  фигуры представляют данные, а фигуры с заливкой—процедуры</font></font></p>
<p>&nbsp;</p><table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index1.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index3.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
</body>
</html>