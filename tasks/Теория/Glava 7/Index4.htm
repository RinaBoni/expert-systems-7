<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index3.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index5.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
<p>&nbsp;</p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3"><font size="4">7.2.1. 
  Передача сообщений</font><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Идея объектно-ориентированного 
  программирования состоит в том, что программа строится вокруг множества объектов, 
  каждый из которых обладает собственным набором функций (операций). Вместо того 
  чтобы представлять объект пассивным набором данных, объектно-ориентированная 
  система позволяет объекту играть более активную роль, в частности взаимодействовать 
  с другими объектами, обмениваясь с ними сообщениями. В результате основной упор 
  переносится с разработки общей управляющей структуры программы, которая ответственна 
  за порядок обращения к функциям, на конструирование самих объектов, выяснение 
  их ролей и создание протоколов взаимодействия объектов. Эти протоколы, по существу, 
  определяют интерфейс между объектами. Если один объект должен взаимодействовать 
  с другим, он должен вызывать функции в строгом соответствии с этим интерфейсом.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Объекты располагают 
  собственными данными, которые играют ту же роль, что и слоты фреймов, собственным 
  механизмом обновления этих данных и использования хранящейся в них информации. 
  Помимо функций интерфейса, объекты располагают собственными, &quot;приватными&quot; 
  функциями, которые, как правило, представляют собой реализацию определенной 
  <i>родовой </i>операции применительно к данному объекту. Помимо данных, передаваемых 
  в качестве аргументов родовой операции, такие функции используют и локальные 
  данные объекта — аналоги слотов фрейма.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Предположим, 
  мы определили объект, представляющий класс ship (корабль), и наделили его свойствами 
  x-velocity (скорость по <i>х) </i>и y-velocity (скорость по <i>у). </i>Теперь 
  можно создать экземпляр класса ship, назвать его Titanic и одновременно присвоить 
  свойствам x-velocity и y-velocity нового экземпляра исходные значения. Практически 
  нет никаких отличий между этой процедурой и процедурой создания нового экземпляра 
  фрейма, рассмотренной в предыдущей главе.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Предположим 
  теперь, что нам понадобилось определить процедуру speed, которая будет вычислять 
  скорость судна на основании значений свойств x-velocity и у-velocity (скорость 
  вычисляется как корень квадратный из суммы квадратов компонентов). Такая процедура 
  будет принадлежать абстрактному типу данных, представляющему любые суда (в терминологии 
  языка SmallTalk speed — это метод класса ships, а в терминологии C++ — <i>функция-член 
  </i>класса ships.)<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Идея состоит 
  в том, чтобы закодировать в объекте (классе) не только декларативные знания 
  о судах, но и процедурные, т.е. методы использования декларативных знаний. Для 
  того чтобы активизировать процедуру вычисления скорости определенного судна, 
  в частности &quot;Титаника&quot;, нужно передать объекту Titanic сообщение, 
  которое побудит его обратиться к ассоциированной процедуре в контексте данных 
  о компонентах скорости именно этого объекта. Titanic — это экземпляр класса 
  ships, от которого он унаследовал процедуру speed. Все это представляется довольно 
  очевидным, но описанный механизм срабатывает только в случае, если соблюдаются 
  следующие соглашения.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Во-первых, 
  программа, разработанная в расчете на этот механизм, должна &quot;учредить&quot; 
  и следовать в дальнейшем определенному протоколу или &quot;контракту&quot;, 
  определяющему способ взаимодействия между объектами. Другими словами, интерфейс 
  обмена сообщениями между объектами должен быть досконально продуман, а правила 
  этого интерфейса жестко соблюдаться. Лучше всего продемонстрировать эту мысль 
  на примере.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Для того чтобы 
  определить компоненту <i>X </i>текущего положения &quot;Титаника&quot;, программа 
  должна послать запрос объекту Titanic, который имел бы следующий смысл: &quot;передай 
  текущее значение координаты <i>X&quot;. </i>Как в объекте формируется это значение 
  или как оно хранится — дело только самого объекта и никого более не касается. 
  Ни объекты других классов, ни какие-либо другие компоненты программы этого не 
  знают. Более того, внутренний механизм доступа к этой информации должен быть 
  скрыт, чтобы никто не мог добраться к ней, минуя сам объект. Это соглашение 
  принято называть <i>инкапсуляцией.</i><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Во-вторых, 
  совершенно очевидна избыточность определения своего метода вычисления скорости 
  для каждого класса объектов, которые обладают возможностью перемещаться в двумерной 
  системе координат. Метод, который мы только что определили для класса судов, 
  с таким же успехом может быть использован и для других движущихся объектов, 
  поскольку вычисление скорости представляет <i>собой родовую операцию. </i>Поэтому 
  имеет смысл связать этот метод с каким-нибудь суперклассом транспортных средств, 
  производными от которого будут классы судов, автомобилей, троллейбусов и т.п. 
  Все эти подклассы унаследуют родовую операцию у своего базового класса.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Такое наследование 
  — это уже нечто большее, чем когнитивная экономия или наследование свойств. 
  Выполнение родовых операций встраивается в механизм обмена сообщениями. Отсылка 
  сообщения— это отнюдь не вызов определенной процедуры, поскольку вызывающий 
  объект не знает, каким именно методом отреагирует на это сообщение объект-получатель, 
  от кого он унаследует этот метод, и будет ли вообще задействован механизм наследования 
  в данном конкретном случае. Вызывающему объекту известны лишь наименование операции 
  и ее внешние по отношению к преемнику аргументы. Все остальное — заботы объекта-реципиента 
  сообщения.<br>
  </font></p>
<p align="center"> <font face="Arial, Helvetica, sans-serif" size="3"><b><font color="#666666">7.2. 
  Формирование объекта класса на языке CLIPS</font></b><font color="#666666"><br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Ниже 
  показано, как на языке CLIPS определяется класс ship и формируется экземпляр 
  этого класса titanic. Сначала определим класс ship, в котором имеются два слота: 
  x-velocity и y-velocity:<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(defclass 
  ship<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(is-a 
  INITIAL_OBJECT)<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(slot 
  x-velocity (create-accessor read-write))<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(slot 
  y-velocity (create-accessor read-write)) )<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">Теперь 
  сформируем экземпляр этого класса,, которому будет дано наименование &quot;Titanic&quot;. 
  Проще всего это сделать с помощью функции definstaces, которая в качестве аргументов 
  принимает список параметров формируемых экземпляров. Определенные таким способом 
  экземпляры класса будут инициализироваться при каждом перезапуске интерпретатора 
  CLIPS.<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(definstances 
  ships (titanic of ship</font></font></p>
<p align="left"><font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3"> 
  (x-velocity 12) (y-velocity (10)<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">Завершается 
  определение созданием обработчика событий для класса ship. Все экземпляры класса 
  будут использовать этот обработчик для вычисления собственной скорости. Обратите 
  внимание на то, что член в этом определении ссылается на значение слота того 
  экземпляра класса, скорость которого требуется вычислить.<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(defmessage-handler 
  ship speed () (sqrt<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">( 
  +<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">{ 
  ?self:x-velocity ?self:x-velocity)</font></font></p>
<p align="left"><font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3"> 
  ( ?self:y-velocity ?self:y-velocity)))</font></font></p>
<p align="left"><font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3"> 
  )<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">Если 
  файл со всеми представленными выше выражениями загрузить в среду CLIPS, а затем 
  ввести с клавиатуры (send [titanic] speed), то в ответ интерпретатор CLIPS выведет 
  скорость объекта titanic.</font><font size="3"></font></font><font face="Arial, Helvetica, sans-serif"><font size="3"></font></font></p>
<p>&nbsp;</p><table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index3.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index5.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
</body>
</html>