<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index5.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index7.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
<p>&nbsp;</p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3"><font size="4">4.3.2. 
  Структура LISP-программы</font><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Как использовать 
  список в качестве базовой структуры данных, понятно. Сложнее представить себе, 
  как можно организовать <i>программу </i>или выражение программы в виде списка. 
  Например, список<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">(+ X Y) представляет 
  математическое выражение в форме<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">(&lt;функция&gt; 
  &lt;1-й аргумент&gt; &lt;2-й аргумент&gt;),</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">которое обозначает 
  сложение двух чисел. Такой метод обозначений (нотация) отличается от привычного 
  нам обозначения функции <i>п </i>переменных в виде <i>f(x<sub>1</sub>, ... </i>x<sub>n</sub>). 
  Но возникает вопрос, как компилятор или интерпретатор отличает данные от программы, 
  если и то и другое представлено списками.<br>
  </font></p>
<ul>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> Необходимо иметь возможность 
    <i>определить значение </i>такого выражения— например, значение выражения 
    ( + X Y). Для этого нужно отыскать определение функции (в данном случае — 
    функции +). В этом определении должна содержаться та последовательность элементарных 
    операций, которую нужно применить к аргументам, чтобы определить значение 
    функции.<br>
    </font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="3"> Нужно иметь средства 
    сформировать <i>определение функции </i>и применить это определение к аргументам, 
    т.е. к действительным, а не формальным параметрам. Механизм определения функции 
    и приложения функции базируется на логической системе, названной <i>лямбда-исчислением 
    </i>(см. <i>[Church, 1941]). </i>Лямбда-исчисление является скорее функциональным, 
    чем исчислением отношений, и в этом состоит различие между ним и исчислением 
    предикатов первого порядка. В функциональном исчислении первичным понятием 
    является отношение &quot;многие-к-одному&quot;, а не &quot;многие-ко-многим&quot;. 
    Так, <i>отец </i>— это функциональное отношение, а <i>брат </i>— более общее 
    отношение, поскольку каждый человек может иметь только одного отца, а братьев 
    может быть несколько. Ниже в этой главе мы более подробно остановимся на связях 
    между языком LISP и лямбда-исчислением.<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> Нужно располагать средствами 
    <i>доступа </i>к текущим значениям переменных (или формальных параметров), 
    таких как X и Y. Вычисление каждого символического выражения выполняется в 
    контексте формирования переменных. Нужно располагать средствами сохранения 
    и восстановления этого контекста при вычислении значений сложных символических 
    выражений, т.е. вычисления и комбинирования значений содержащихся в них подвыражений.<br>
    </font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="3"> При вычислении сложных 
    символических выражений, когда необходимо вычислять значения его компонентов, 
    которые являются сложными выражениями, нужно располагать средствами <i>сохранять 
    текущее </i>выражение и промежуточные результаты. Необходимо также обладать 
    средствами <i>копирования </i>символических выражений.<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> Нужно уметь подавлять 
    вычислительную обработку списков, которые не являются операторами программы, 
    а структурами данных. Например, не нужно пытаться вычислять выражение, подобное 
    следующему:<br>
    </font></li>
</ul>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">((1 
  2 3)(4 5 6)(7 8 9))</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">и пытаться 
  отыскать определение функции (1 2 3).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Для этого 
  существует специальная форма выражения (QUOTE X) для любых X, которая возвращает 
  X. Точно такое же действие выполняется и выражением (quote X).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Современные 
  версии LISP не чувствительны к регистру символов, хотя и возможно так сконфигурировать 
  исполнительную систему, что она станет по-разному воспринимать символы верхнего 
  и нижнего регистров.<br>
  </font></p>
<p align="center"> <font face="Arial, Helvetica, sans-serif" size="3"><b><font color="#666666">4.3. 
  Функции, их вычисление и проблема цитирования в CLIPS</font></b><font color="#666666"><br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Существуют 
  два основных метода разрешения проблемы цитирования, т.е. предотвращения интерпретации 
  данных как функций или выражений. Один метод заключается в том, чтобы в число 
  системных функций ввести специальную функцию, которая рассматривается интерпретатором 
  как указание не обрабатывать последующий список. Такой системной функцией в 
  LISP является QUOTE. Другой метод<sup> </sup>состоит в том, чтобы по умолчанию 
  подавлять механизм оценивания значения (вычисления) до тех пор, пока специальная 
  синтаксическая конструкция его не запустит. В языке CLIPS использован именно 
  такой метод.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">Например, 
  в CLIPS можно следующим образом определить функцию:<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(deffunction 
  between(?lb ?value ?ub) </font></font></p>
<p align="left"><font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(or 
  (&gt; lib ?value) (&gt; ?value ?ub))))<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">Эта 
  функция определяет, попало ли заданное целочисленное значение в диапазон между 
  указанными нижним и верхним пределами. Знак вопроса, предшествующий именам, 
  говорит интерпретатору CLIPS, что выражения ?lb, ?value и ?ub являются переменными 
  и их не нужно оценивать.</font></font><font face="Arial, Helvetica, sans-serif"><font size="3"><br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Общепринятым 
  методом реализации функциональных языков типа LISP является использование четырехстековой 
  машины, за которой закрепилось наименование SECD-машины. В четырех стеках машины 
  отслеживаются промежуточные результаты, значения переменных, текущее выражение 
  и копии текущего состояния процесса вычислений сложного выражения, которые нужны, 
  чтобы восстановить состояние после завершения вычисления вложенного выражения 
  (подвыражения). Не вдаваясь в подробности, отметим, что процесс оценивания символического 
  выражения в такой машине — это не что иное, как реализация базовой операции 
  приложения функции, как это определено в лямбда-исчислении (см., например, [Henderson, 
  1980], [Glaser et al., 1984]).</font></p>
<p>&nbsp;</p><table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index5.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index7.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
</body>
</html>