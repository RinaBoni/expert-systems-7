<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index3.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index5.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
<p>&nbsp;</p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3"><font size="4">3.2.1. 
  Таблицы операторов и методика &quot;средство -анализ завершения&quot;</font><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Допустимые 
  операции, такие как перемещение робота из одной комнаты в другую или проталкивание 
  объектов, кодируются в <i>таблице операторов. </i>Ниже показан элемент этой 
  таблицы, соответствующий операции push (толкать):<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">push(X, 
  Y, Z)<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">Предварительные 
  условия at(po6oT, Y), at(X, Y)<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">Список 
  удалений at (робот, Y), at(X, Y)<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">Список 
  добавлений at (робот, Z), at(X, Z)<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">Здесь 
  выражение push(X, Y, Z)</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">означает, 
  что объект <i>X </i>выталкивается (роботом) из положения <i>Y </i>в положение 
  <i>Z, </i>причем <i>X, Y и Z </i>— переменные в области значений, охватывающей 
  доступное множество объектов, в то время как робот, комнатаА, ящик1, комнатаБ, 
  ящик2, комнатаВ — это имена конкретных объектов из этого множества.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">С точки зрения 
  программиста переменные <i>X, </i>К и Z в определении оператора, заданном элементом 
  таблицы, — это аналоги формальных параметров в определении процедуры, которая 
  соответствует такому действию:<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">&quot;Вытолкнуть 
  какой-либо объект из какого-либо положения в любое другое положение, если имеют 
  место заданные предварительные условия; затем удалить формулы, указанные в списке 
  удаления, и добавить формулы, указанные в списке добавления&quot;.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">С точки зрения 
  логики элемент push таблицы операторов может быть прочитан в виде формулы, которая 
  утверждает:<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">&quot;При 
  любых <i>X, Y</i> и Z объект <i>X </i>выталкивается из Y в Z, если робот и объект 
  X находятся в 7, а затем состояние изменятся заменой Y на Z&quot;.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Целевое состояние 
  также представляется формулой, например: а1(ящик1, комнатаА), а^ящик2, комнатаБ).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Программа 
  STRIPS включает множество процедур, которые выполняют различные функции, в частности:<br>
  </font></p>
<ul>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> обработка списка целей;<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> выбор очередной цели;<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> поиск операторов, которые 
    могут быть использованы для достижения текущей цели; </font></li>
  <li><font face="Arial, Helvetica, sans-serif" size="3"> анализ соответствия 
    между целью и формулам в списке добавлений в модель;<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> установка сформулированных 
    предварительных условий в качестве подцелей.<br>
    </font></li>
</ul>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Чтобы представить 
  себе, как на практике использовать подобную &quot;структуру представлений, рассмотрим 
  простую задачу: как готовиться к ленчу с потенциальным клиентом. Для этого, 
  во-первых, нужно иметь в своем распоряжении определенную сумму наличных денег, 
  чтобы расплатиться, во-вторых, нужно проголодаться, поскольку речь идет о приеме 
  пищи. Сформулированные условия можно рассматривать в качестве предварительных 
  для достижения цели &quot;ленч&quot;. Эта цель может быть представлена оператором, 
  как на рис. 3.1. После завершения ленча деньги будут потрачены, а у вас исчезнет 
  чувство голода. Эти простые факты нашли отражение в списках удалений и добавлений 
  для оператора have lanch. Однако обладание известной суммой наличных денег нельзя 
  рассматривать как естественное состояние клиента. Сначала нужно получить их 
  в банкомате, что, в свою очередь, требует передвижения. Следовательно, нужно 
  добавить в таблицу операторов еще два элемента — at cash mashine (передвижение 
  к банкомату) и have money (получение наличности).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Этот простой 
  пример обладает довольно интересными свойствами. Отметим, что формулы для модели 
  мира в исходном состоянии<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">at(work), 
  have(transport)</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">остаются в 
  неприкосновенности до тех пор, пока мы явно не удалим их. Таким образом, у вас 
  остается возможность передвигаться по городу на протяжении всего времени реализации 
  плана, поскольку формально отсутствуют какие-либо признаки, что эта возможность 
  может быть утеряна (например, автомобиль будет угнан, или вы попадете в дорожную 
  аварию, или по дороге к банкомату кончится бензин). Точно так же может что-нибудь 
  произойти и с банкоматом — он может &quot;зажевать&quot; карточку, или вы можете 
  забыть вытащить ее, или может вдруг появиться механическая рука и ножницами 
  разрезать ее. Но предполагается, что последовательность действий, представленная 
  в сгенерированном машиной плане, не должна предвидеть такие исключительные ситуации, 
  хотя в реальной обстановке это соблюдается далеко не всегда.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Такая стратегия 
  &quot;обратных&quot; рассуждений, т.е. от целей к подцелям, чрезвычайно распространена 
  в программах искусственного интеллекта и экспертных системах, как вы вскоре 
  убедитесь на примере системы MYCIN. Но даже на таком ограниченном множестве 
  операторов, как в нашем примере, может существовать несколько вариантов выполнения 
  действий. В этом случае необходимо будет организовать какой-то механизм поиска 
  наилучшей последовательности операторов, приводящих к достижению сформулированной 
  цели.<br>
  </font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif"><img src="1.gif" width="500" height="596"> 
  </font></p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="3">Рис. 3.1. 
  Таблица операторов для задачи &quot;Ленч&quot;<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">По существу, 
  в системе STRIPS при выборе операторов выполняется поиск в пространстве состояний, 
  как это было описано в главе 2. В результате формируется <i>план, </i>т.е. последовательность 
  операторов, приводящая к достижению цели, причем за основу берется стратегия 
  &quot;обратного&quot; прослеживания. Основное отличие STRIPS от других аналогичных 
  программ состоит в том, что вместо методики &quot;генерация —проверка&quot; 
  для передвижения в пространстве состояний используется другой метод, известный 
  как &quot;средство — анализ завершения&quot; <i>(means-ends analisys).</i><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В контексте 
  нашей задачи применение методики &quot;генерация —проверка&quot; означает следующее: 
  для каждого текущего состояния предпринимаются попытки использовать все возможные 
  операторы, причем после каждой попытки анализируется, не привела ли она к желанной 
  цели. Но такая методика явно бессмысленна, поскольку количество разнообразных 
  операций, которые робот способен выполнить в некоторой произвольной ситуации, 
  очень велико, причем многие из этих операций не имеют никакого отношения к достижению 
  заданной цели. Уже после нескольких первых испытаний размерность пространства 
  состояний увеличится и будет экспоненциально нарастать с каждым новым испытанием. 
  Совершенно очевидно, что в данном случае нужна совершенно иная стратегия.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Основная идея, 
  которая лежит в основе метода &quot;средство — анализ завершения&quot;, состоит 
  в том, чтобы с каждой новой операцией отличие между текущим состоянием и целевым 
  уменьшалось, т.е. каждая очередная операция должна приближать нас к цели. Но 
  это предполагает включение в рассмотрение некоторой меры для оценки &quot;расстояния&quot; 
  в пространстве состояний. Такая мера очень походит на оценочную функцию. Если 
  очередная цель сформулирована в виде<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">at(ящик1, 
  комнатаА),</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">а ящик находится 
  в комнате Б, то перемещение робота из комнаты А в комнату В никак не &quot;приблизит&quot; 
  текущее состояние к целевому. А вот перемещение робота из комнаты А в комнату 
  Б уменьшит расстояние между текущим и целевым состоянием, поскольку робот теперь 
  сможет на очередном шаге вытолкнуть ящик из комнаты Б в комнату А. В этом смысле 
  поведение робота &quot;мотивируется&quot; от целевого состояния к подцелям, 
  которые могут привести к достижению сформулированной цели.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В действительности 
  программа STRIPS считывает список целей наподобие такого:<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">at(ящик1, 
  комнатаА), аt(ящик2, комнатаБ),<br>
  </font><font face="Arial, Helvetica, sans-serif" size="3"> </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">а затем сопоставляет 
  эти цели и список добавления в описании каждого оператора. Так, цель at (ящик!, 
  комнатаА) будет соответствовать элементу at(X, Z) в списке добавлений оператора 
  push (X, Y, Z).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Схема сопоставления 
  будет подробно рассмотрена в главах 4, 5 и 8, но сейчас, не вдаваясь в детали, 
  просто отметим, что существует <i>подстановка </i>значений переменных<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">Х/ящик1, 
  Z/комнатаА,</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">которая приводит 
  к равенству выражений at (ящик!, комнатаА) nat(X, Z).<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Программа 
  следующим образом формирует подцели, выбирая в качестве таковых предварительные 
  условия оператора.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">(1) Подстановкой 
  {Х/ящик1, Z/комнатаА} <i>означить </i>предварительное условие, которое является 
  производным от соответствия at (ящик!, комнатаА) nat(X, Z), и получить таким 
  образом<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">at(po6oт 
  , Y), at(ящик1, Y).</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">(2) <i>Найти 
  </i>в модели мира формулу, которая представляла бы текущее положение ящика а1(ящик1, 
  комнатаБ), сравнить ее с at(ящик1, Y) и в результате этого сравнения сформулировать 
  подстановку {Y/комнатаБ}, которую затем применить к уже частично означенному 
  предварительному условию. В результате будет сформулирована очередная подцель:<br>
  </font></p>
<p align="left"> <font face="Verdana, Arial, Helvetica, sans-serif" size="3">at(робот, 
  комнатаБ), at(ящик1, комнатаБ).</font><font face="Arial, Helvetica, sans-serif" size="3"><br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Теперь первое 
  предварительное условие даст желаемое (целевое) положение робота, а второе предварительное 
  условие уже выполнено.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Так как таблица 
  операторов, модель мира и цели представлены с помощью одного и того же синтаксиса 
  в виде конструкций <i>предикат-аргумент, </i>то, применяя описанную выше схему 
  сопоставления, программа довольно просто находит, какие именно операции нужно 
  выполнить для достижения поставленной цели. Все, что нужно для этого сделать, 
  — просмотреть списки добавлений в описании операторов и найти в них элемент, 
  соответствующий заданной цели, как это показано на рис. 3.1.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Подцели формулируются 
  на основе анализа предварительных условий, заданных для операторов, <i>означивая 
  </i>их подстановкой переменных из формулы модели мира. Как только выбран нужный 
  оператор, его предварительные условия преобразуются и добавляются в список подцелей. 
  Если в текущем состоянии можно применить не один оператор, то для выбора между 
  &quot;кандидатами&quot; нужно применить какую-либо эвристику. Например, можно 
  выбрать тот из операторов, который сулит наибольшее сокращение &quot;расстояния&quot; 
  между текущим состоянием и целевым. Другой возможный вариант — операторы в таблице 
  заранее упорядочены и нужно применять тот из них, который стоит в списке раньше.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Весь процесс 
  решения проблемы по такой методике имеет ярко выраженный рекурсивный характер. 
  Подцели могут, в свою очередь, приводить к формулировке подподце-лей и т.д. 
  На самом нижнем уровне окажутся подцели, которые реализуются операторами, либо 
  не имеющими предварительных условий, либо имеющими такие предварительные условия, 
  которые удовлетворяются тривиально. Мы рассмотрим подробно методику &quot;средство 
  — анализ завершения&quot; в главах 5 и 14.</font></p>
<p>&nbsp;</p><table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index3.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index5.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
</body>
</html>