<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<title></title>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
</head>
<body TEXT="#000000" BGCOLOR="#E7E3E7" LINK="#004080" VLINK="#004080" olink="#008080" Background="">
<table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index7.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index9.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
<p>&nbsp;</p>
<p align="center"><font face="Arial, Helvetica, sans-serif" size="4">17.3.4. Многофункциональные 
  программные среды<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Многофункциональные 
  программные среды позволяют опытному программисту экспериментировать при решении 
  новых классов проблем, выбирая подходящие сочетания различных методов, представленных 
  в имеющемся модульном наборе. Поскольку не существует единственного универсального 
  языка представления знаний для произвольной экспертной системы, у разработчиков 
  возникает желание объединить несколько различных схем представления, особенно 
  на этапе создания прототипа. Хотя исчерпывающей теории таких гибридных систем 
  и не существует, эксперименты с разными схемами представления и логического 
  вывода показали, что каждая из них имеет свои слабые стороны. Поэтому понятно 
  желание объединить разные методики таким образом, чтобы достоинства одних компенсировали 
  слабости других.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Мы уже не 
  раз обращали ваше внимание на то, что порождающие правила позволяют представить 
  в программе эмпирически выявленные связи между условиями и действиями, между 
  наблюдениями и гипотезами, но они значительно хуже подходят для представления 
  отношений между объектами предметной области, включая и такие важнейшие, как 
  отношения <i>множество/элемент </i>или <i>множество/подмножество. </i>Структурированные 
  объекты, например фреймы, оказываются более удобным средством для хранения и 
  манипулирования описаниями объектов предметной области, но применение таких 
  знаний требует включения в программу фрагментов программного кода (например, 
  на языке LISP), которые затем трудно анализировать. Рациональное зерно в первых 
  попытках свести вместе стили, основанные на правилах и фреймах, состояло в том, 
  чтобы объединить способность представлять объекты, характерные для фреймов, 
  с возможностями связывать условия и действия с помощью порождающих правил.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">Одной из первых 
  многофункциональных сред искусственного интеллекта является LOOPS <i>[Bobrow 
  and Steflk, 1983], </i>в которой в рамках единой архитектуры обмена сообщениями 
  были объединены четыре парадигмы программирования, перечисленные ниже.<br>
  </font></p>
<ul>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> <b>Процедурно-ориентированное 
    программирование. </b>Эта парадигма была представлена языком LISP, в котором 
    активным компонентом являются процедуры, а пассивным — данные, несмотря на 
    то, что в LISP процедуры сами по себе также являются данными, поскольку имеют 
    вид списков. В рамках единой среды процедуры могут быть использованы для обработки 
    внешних данных, в частности изменения значений общедоступных переменных.<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> <b>Программирование, 
    ориентированное на правила. </b>Эта парадигма аналогична предыдущей, но роль 
    процедур играют правила &quot;условие-действие&quot;. В среде LOOPS наборы 
    правил сами по себе являются объектами, которые можно рекурсивно вкладывать 
    один в другой. Таким образом, часть &quot;действие&quot; одного правила, в 
    свою очередь, может активизировать подчиненный набор правил. С множествами 
    правил связываются управляющие компоненты, с помощью которых в простейшей 
    форме выполняется разрешение конфликтов.<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"> <b>Объектно-ориентированное 
    программирование. </b>Структурированные объекты обладают свойствами и процедур, 
    и данных, причем побочные эффекты обычно локализуются в пределах объекта. 
    Обработка поступающих сообщений приводит к передаче данных или изменению их 
    значений, но все манипуляции данными выполняются под управлением того компонента, 
    который обратился к объекту. При этом вызывающий объект совершенно не интересует, 
    как хранятся данные и как они модифицируются внутри объекта.<br>
    </font></li>
  <li> <font face="Arial, Helvetica, sans-serif" size="3"><b> Программирование, 
    ориентированное на данные. </b>Доступ к данным и обновление данных запускает 
    определенные процедуры, причем не имеет значения, почему изменен компонент 
    данных, — то ли это результат побочного эффекта, то ли результат действия 
    других процедур. С переменными, в которых хранятся значения данных, связываются 
    определенные процедуры, подобно тому, как это делается в слотах фрейма, причем 
    такие переменные часто называют <i>активными величинами. </i>В таких приложениях, 
    как моделирование, этот стиль программирования оказывается довольно продуктивным, 
    поскольку позволяет распространить эффект изменения какого-либо компонента 
    на прочие, с ним связанные.<br>
    </font></li>
</ul>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В рамках основной 
  объектно-ориентированной парадигмы модули среды, поддерживающие разные стили 
  программирования, можно комбинировать. Обычно условия в порождающих правилах 
  и логические фразы связываются со значениями слотов структурированных объектов, 
  а правила модифицируют значения этих слотов. Именно такой стиль объединения 
  парадигм в настоящее время реализован в языке CLIPS.<br>
  </font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3">В системах 
  КЕЕ и LOOPS поведение объектов описывается в терминах множества порождающих 
  правил, как это сделала Эйкинс (Aikins) в системе CENTAUR (см. об этой системе 
  в главах 13 и 16). В средах КЕЕ и Knowledge Craft к перечисленным выше парадигмам 
  добавлено и логическое программирование в стиле языка PROLOG. Новая версия КЕЕ, 
  известная под названием КАРРА-РС, предоставляет в распоряжение программиста 
  еще более широкий набор стилей для комбинирования правил, объектов и процедур.<br>
  </font></p>
<p align="center"> <font face="Arial, Helvetica, sans-serif" size="3"><b><font color="#666666">17.1. 
  CUPS как многофункциональная среда программирования</font></b><font color="#666666"><br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" size="3" color="#666666">Кроме 
  поддержки интерпретатора порождающих правил, описанного в главе 5, CLIPS обладает 
  следующими функциональными возможностями:<br>
  </font></p>
<ul>
  <li><font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3"> 
    для определения стандартных функций используется синтаксис, подобный LISP 
    (сведения о LISP вы найдете в главе 4);<br>
    </font></font></li>
  <li> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3"> 
    предоставляет в распоряжение разработчика родовые функции, аналогичные мультиметодам 
    CLOS (см. главу 7);<br>
    </font></font></li>
  <li> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3"> 
    располагает встроенным объектно-ориентированным языком COOL, который, в отличие 
    от CLOS, включает и средства поддержки обмена сообщениями.<br>
    </font></font></li>
</ul>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">Обращение 
  к стандартным функциям допускается включать в правую часть правил и в этом случае 
  они выполняются так, как если бы являлись компонентом действий, специфицированных 
  в правиле. Функции вызываются либо с целью получить побочный эффект, либо для 
  использования явно возвращаемого функцией результата, который может быть сохранен 
  с помощью оператора присваивания. Для работы с переменными в этом случае используется 
  тот же синтаксис, что и в языке описания правил. Например, можно определить 
  функцию between (X, Y, 2), оперирующую с целыми переменными. Эта функция будет 
  проверять выполнение неравенств X[Y[Z:<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(deffunction 
  between (?lb ?value ?ub)<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(and 
  (&lt;= ?lb ?value) (&lt;=?value ?ub))),<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">Родовые 
  функций (generic function) в CLIPS играют ту же роль, что и перегружаемые операторы 
  в языке C++. Они обеспечивают возможность выполнять обработку разными методами 
  последовательностей данных различного типа. Например, для конкатенации двух 
  строковых значений оператором + можно следующим образом перегрузить этот оператор:<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(defmethod 
  + ((?a STRING) (?b STRING)) (art-cat ?a ?b)}<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">Тогда 
  результатом вычисления выражения<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">(+ 
  &quot;dog&quot; &quot;fish&quot;) будет &quot;dogfish&quot;.<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">В 
  такой функции можно смешивать ограниченные и неограниченные параметры, причем 
  ограничение может касаться типов данных на произвольном уровне обобщения, например 
  числовых данных, целых, положительных целых чисел и т.д.<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">Вычисление 
  родовых функций выполняется под &quot;надзором&quot; родового алгоритма диспетчирования 
  (generic dispatch algorithm), который формирует индексированный список подходящих 
  методов. Методы из этого списка затем вызываются соответственно уровню ограничений, 
  указанному для параметров при обращении к функции. Алгоритм также принимает 
  во внимание любые управляющие программные конструкции, представленные явно в 
  тексте программы метода, например call-next-method или override-next-method.<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">Механизм 
  передачи сообщений реализован по тому же способу, что и в языках SmallTalk и 
  LOOPS, и требует, чтобы программист разработал свой обработчик сообщений для 
  каждого отдельного класса. Диспетчер сообщений работает так? же, как в исполняющей 
  системе языка CLOS, и различает обработчики типов primary, around, before и 
  after.<br>
  </font></font></p>
<p align="left"> <font face="Arial, Helvetica, sans-serif" color="#666666"><font size="3">В 
  программе на языке CLIPS можно вызывать и функции, написанные на языке С, хотя 
  это и выполняется несколько необычно. Исполняющая система CLIPS может выступать 
  в качестве внедренного приложения, т.е. программа на CLIPS может быть скомпилирована 
  и скомпонована с программой на языке С, которая будет вызывать CLIPS-фрагменты 
  как подпрограммы. Это позволяет внедрять функции искусственного интеллекта в 
  компоненты больших программных комплексов.</font><font size="3"></font></font><font face="Arial, Helvetica, sans-serif"><font size="3"></font></font></p>
<p>&nbsp;</p><table BORDER=0   COLS=3 WIDTH="16%" >
  <tr> 
    <td><font face="Arial, Helvetica, sans-serif"><a href="Index7.htm"><img SRC="Back.gif"  BORDER=0 ></a></font></td>
    <td WIDTH="10%"><font face="Arial, Helvetica, sans-serif"><a href="../index.html"><img SRC="Menu.gif" BORDER=0 ></a></font></td>
    <td ALIGN=RIGHT><font face="Arial, Helvetica, sans-serif"><a href="Index9.htm"><img SRC="For.gif" BORDER=0 ></a></font></td>
  </tr>
</table>
</body>
</html>